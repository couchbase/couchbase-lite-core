//
// Signing.hh
//
// Copyright 2022-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#pragma once
#include "Base.hh"
#include "PublicKey.hh"

namespace litecore::crypto {


    static constexpr const char* kRSAAlgorithmName = "RSA";
    static constexpr const char* kEd25519AlgorithmName = "Ed25519";


    /** Abstract base class of (private) keys that can create signatures. */
    class SigningKey {
    public:
        /// Generates a digital signature of `inputData` with this key.
        virtual alloc_slice sign(slice inputData) const =0;

        /// Returns the data of the (public) key that can be used to verify signatures.
        virtual alloc_slice verifyingKeyData() const =0;

        /// The short name of the algorithm used, "RSA" or "Ed25519".
        virtual const char* algorithmName() const =0;

        virtual ~SigningKey() = default;
    };


    /** Abstract base class of (public) keys that can verify signatures. */
    class VerifyingKey {
    public:
        /// Creates a VerifyingKey, using the given algorithm, from the given data.
        /// Does not return `nullptr`.
        /// Throws `error::CryptoError` if the algorithm is unknown or the data is invalid for it.
        static std::unique_ptr<VerifyingKey> instantiate(slice data, const char *algorithm);

        /// The key data.
        virtual alloc_slice data() const =0;

        /// Returns true if `signature` is a valid signature, generated by my corresponding
        /// `SigningKey`, of `data`.
        virtual bool verifySignature(slice inputData, slice signature) const =0;

        /// The short name of the algorithm used, "RSA" or "Ed25519".
        virtual const char* algorithmName() const =0;

        virtual ~VerifyingKey() = default;
    };


#pragma mark - RSA:


    /** Keys for the RSA signature algorithm with SHA256 digests. */


    /** Wrapper for an (RSA) PrivateKey object, that implements `SigningKey`. */
    class RSASigningKey : public SigningKey {
    public:
        RSASigningKey(PrivateKey *rsaKey)               :_key(rsaKey) { }
        RSASigningKey(Retained<PrivateKey> &&rsaKey)    :_key(std::move(rsaKey)) { }

        const char* algorithmName() const override      {return kRSAAlgorithmName;}
        alloc_slice sign(slice data) const override     {return _key->sign(data);}
        alloc_slice verifyingKeyData() const override   {return _key->publicKeyData();}

    private:
        Retained<PrivateKey> _key;
    };


    /** Wrapper for an (RSA) PublicKey object, that implements `VerifyingKey`. */
    class RSAVerifyingKey : public VerifyingKey {
    public:
        RSAVerifyingKey(PublicKey *rsaKey)              :_key(rsaKey) { }
        RSAVerifyingKey(Retained<PublicKey> &&rsaKey)   :_key(std::move(rsaKey)) { }
        explicit RSAVerifyingKey(slice data)            :_key(new PublicKey(data)) { }

        const char* algorithmName() const override      {return kRSAAlgorithmName;}
        alloc_slice data() const override               {return _key->publicKeyData(KeyFormat::DER);}
        bool verifySignature(slice dat,
                             slice sig) const override  {return _key->verifySignature(dat, sig);}
    private:
        Retained<PublicKey> _key;
    };


#pragma mark - Ed25519:


    /** Keys for the Ed25519 signature algorithm with SHA512 digests.

        Ed25519 is an elliptic curve algorithm, very similar to Curve25519, but used for signatures
        instead of encryption. Its advantages over RSA are order-of-magnitude smaller key and
        signature sizes (256 bits vs. 2048+) with equivalent security, and higher performance.
        <https://en.wikipedia.org/wiki/EdDSA>  <https://ed25519.cr.yp.to>  */


    // A base class, not used directly
    class Ed25519Base {
    public:
        /// Size of a key, in bytes.
        static constexpr size_t kKeySize = 32;
    protected:
        Ed25519Base() = default;
        explicit Ed25519Base(slice bytes);
        slice data() const                              {return {_bytes.data(), _bytes.size()};}

        std::array<uint8_t,kKeySize> _bytes;
    };


    /** A public key for the Ed25519 elliptic-curve signature algorithm with SHA512 digests.
        Ed25519 is very similar to Curve25519, but used for signatures instead of encryption.
        SHA512 is used to digest the input data; the elliptic curve signs the digest. */
    class Ed25519VerifyingKey : public VerifyingKey, Ed25519Base {
    public:
        /// Constructs a public verifying key from its 32-byte data representation.
        explicit Ed25519VerifyingKey(slice bytes);

        const char* algorithmName() const override      {return kEd25519AlgorithmName;}
        alloc_slice data() const override               {return alloc_slice(Ed25519Base::data());}
        bool verifySignature(slice data, slice signature) const override;
    private:
        friend class Ed25519SigningKey;
        Ed25519VerifyingKey() = default;
    };


    /** A private key for the Ed25519 elliptic-curve signature algorithm. */
    class Ed25519SigningKey : public SigningKey, Ed25519Base {
    public:
        /// Generates a key-pair at random and returns the private signing key.
        static Ed25519SigningKey generate()                 {return Ed25519SigningKey();}

        /// Constructs a key from its 32-byte data representation.
        explicit Ed25519SigningKey(slice bytes)             :Ed25519Base(bytes) { }

        /// Returns the key's data. This should only be stored in a secure location.
        slice data() const                                  {return Ed25519Base::data();}

        /// Returns the corresponding public key.
        /// @note  This is somewhat expensive to compute, so consider reusing the object.
        Ed25519VerifyingKey publicKey() const;

        const char* algorithmName() const override          {return kEd25519AlgorithmName;}
        alloc_slice sign(slice data) const override;
        alloc_slice verifyingKeyData() const override;

    private:
        Ed25519SigningKey();
    };

}
