//
// Signing.hh
//
// Copyright 2022-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#pragma once
#include "Base.hh"
#include "PublicKey.hh"

namespace litecore::crypto {

    // Why create these interfaces, when PublicKey and PrivateKey already exist?
    // The implementations of PublicKey and PrivateKey (and some of their API) are tied to mbedTLS.
    // But mbedTLS doesn't implement Ed25519. So in order to create Ed25519PublicKey and
    // Ed25519PrivateKey subclasses we'd have to heavily refactor the current `Key` class hierarchy
    // and move the mbed-specific stuff to new `RSAPublicKey` and `RSAPrivateKey` classes.
    // That didn't seem worth the trouble.

    static constexpr const char* kRSAAlgorithmName = "RSA";
    static constexpr const char* kEd25519AlgorithmName = "Ed25519";

    class VerifyingKey;


    /** Abstract interface of (private) cryptographic keys that can create signatures. */
    class SigningKey {
    public:
        /// Static factory method that generates a random key-pair of the given algorithm.
        /// Throws `error::CryptoError` if the algorithm is unknown or the data is invalid for it.
        static std::unique_ptr<SigningKey> generate(const char *algorithm);

        /// Generates a digital signature of `inputData` with this key.
        virtual alloc_slice sign(slice inputData) const =0;

        /// Instantiates a matching public verifying key.
        virtual std::unique_ptr<VerifyingKey> verifyingKey() const =0;

        /// Returns the data of the corresponding (public) key that can be used to verify signatures.
        virtual alloc_slice verifyingKeyData() const =0;

        /// The short name of the algorithm used, "RSA" or "Ed25519".
        virtual const char* algorithmName() const =0;

        virtual ~SigningKey() = default;
    };


    /** Abstract interface of (public) cryptographic keys that can verify signatures. */
    class VerifyingKey {
    public:
        /// Static factory method that creates a VerifyingKey, using the given algorithm, from the
        /// given data.
        /// Throws `error::CryptoError` if the algorithm is unknown or the data is invalid for it.
        static std::unique_ptr<VerifyingKey> instantiate(slice data, const char *algorithm);

        /// The key data in binary form.
        virtual alloc_slice data() const =0;

        /// Returns true if `signature` is a valid signature, generated by my corresponding
        /// `SigningKey`, of `data`.
        virtual bool verifySignature(slice inputData, slice signature) const =0;

        /// The short name of the algorithm used, "RSA" or "Ed25519". (See constants above.)
        virtual const char* algorithmName() const =0;

        virtual ~VerifyingKey() = default;
    };


#pragma mark - RSA:


    /** Keys for the RSA signature algorithm with SHA256 digests. */


    /** Wrapper for an (RSA) PrivateKey object, that implements `SigningKey`. */
    class RSASigningKey : public SigningKey {
    public:
        RSASigningKey(PrivateKey *rsaKey)               :_key(rsaKey) { }
        RSASigningKey(Retained<PrivateKey> &&rsaKey)    :_key(std::move(rsaKey)) { }

        const char* algorithmName() const override      {return kRSAAlgorithmName;}
        alloc_slice sign(slice data) const override;
        std::unique_ptr<VerifyingKey> verifyingKey() const override;
        alloc_slice verifyingKeyData() const override   {return _key->publicKeyData();}

    private:
        Retained<PrivateKey> _key;
    };


    /** Wrapper for an (RSA) PublicKey object, that implements `VerifyingKey`. */
    class RSAVerifyingKey : public VerifyingKey {
    public:
        RSAVerifyingKey(PublicKey *rsaKey)              :_key(rsaKey) { }
        RSAVerifyingKey(Retained<PublicKey> &&rsaKey)   :_key(std::move(rsaKey)) { }
        explicit RSAVerifyingKey(slice data)            :_key(new PublicKey(data)) { }

        const char* algorithmName() const override      {return kRSAAlgorithmName;}
        alloc_slice data() const override               {return _key->publicKeyData(KeyFormat::DER);}
        bool verifySignature(slice dat,
                             slice sig) const override;
    private:
        Retained<PublicKey> _key;
    };


#pragma mark - Ed25519:

    /** Keys for the Ed25519 signature algorithm with SHA512 digests.

        Ed25519 is an elliptic curve algorithm, very similar to Curve25519, but used for signatures
        instead of encryption. Its advantages over RSA are order-of-magnitude smaller key and
        signature sizes (256 bits vs. 2048+) with equivalent security, and higher performance.
        <https://en.wikipedia.org/wiki/EdDSA>  <https://ed25519.cr.yp.to>  */


    class Ed25519VerifyingKey;

    // A base class, not used directly
    class Ed25519Base {
    public:
        /// Size of a key, in bytes.
        static constexpr size_t kKeySize = 32;

        /// Size of a signature, in bytes.
        static constexpr size_t kSignatureSize = 64;

    protected:
        Ed25519Base() = default;
        explicit Ed25519Base(slice bytes);
        slice _data() const                              {return {_bytes.data(), _bytes.size()};}

        std::array<uint8_t,kKeySize> _bytes;
    };


    /** A private key for the Ed25519 elliptic-curve signature algorithm. */
    class Ed25519SigningKey : public SigningKey, Ed25519Base {
    public:
        /// Generates a key-pair at random.
        Ed25519SigningKey();

        /// Generates a key-pair at random and returns the private signing key.
        static Ed25519SigningKey generate()                 {return Ed25519SigningKey();}

        /// Constructs a key from its 32-byte data representation.
        explicit Ed25519SigningKey(slice bytes)             :Ed25519Base(bytes) { }

        /// Returns the key's data. This should only be stored in a secure location.
        slice data() const                                  {return Ed25519Base::_data();}

        /// Returns the corresponding public key.
        /// @note  This is somewhat expensive to compute, so consider reusing the object.
        Ed25519VerifyingKey publicKey() const;

        const char* algorithmName() const override          {return kEd25519AlgorithmName;}
        alloc_slice sign(slice data) const override;
        std::unique_ptr<VerifyingKey> verifyingKey() const override;
        alloc_slice verifyingKeyData() const override;

    private:
    };


    /** A public key for the Ed25519 elliptic-curve signature algorithm with SHA512 digests.
        Ed25519 is very similar to Curve25519, but used for signatures instead of encryption.
        SHA512 is used to digest the input data; the elliptic curve signs the digest. */
    class Ed25519VerifyingKey : public VerifyingKey, Ed25519Base {
    public:
        /// Constructs a public verifying key from its 32-byte data representation.
        explicit Ed25519VerifyingKey(slice bytes);

        const char* algorithmName() const override      {return kEd25519AlgorithmName;}
        alloc_slice data() const override               {return alloc_slice(Ed25519Base::_data());}
        bool verifySignature(slice data, slice signature) const override;
    private:
        friend class Ed25519SigningKey;
        Ed25519VerifyingKey() = default;
    };

}
