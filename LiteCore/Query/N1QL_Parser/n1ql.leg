#
#  n1ql.leg
#
# Copyright 2019-Present Couchbase, Inc.
#
# Use of this software is governed by the Business Source License included in
# the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
# file, in accordance with the Business Source License, use of this software
# will be governed by the Apache License, Version 2.0, included in the file
# licenses/APL2.txt.
#

# Grammar file for N1QL parser
# To be compiled by the 'leg' tool with Jens's modifications -- <http://github.com/snej/peg/>:
#     leg -o n1ql.cc n1ql.leg
# The output file must be compiled as C++!

%{
#include "n1ql_parser_internal.hh"

namespace litecore { namespace n1ql {
%}


n1ql = y_
    s:selectStatement y_ !.            { $$ = s;}
    |
    sr:selectResults !.               { MutableDict dict = MutableDict::newDict();
                                        setAny(dict, "WHAT", sr);
                                        $$ = dict; }


######## SELECT STATEMENT:


selectStatement =
    select:SELECT y_                     { select = MutableDict::newDict(); }
        (d:DISTINCT                     { setAny(select, "DISTINCT"_sl, true); }
         | ALL)?
        sr:selectResults y_              { setAny(select, "WHAT"_sl, sr); }
        (f:from y_                       { setAny(select, "FROM"_sl, f); }
            )?
        (WHERE w:expression             { setAny(select, "WHERE"_sl, w); }
            )?
        (g:groupBy y_                    { setAny(select, "GROUP_BY"_sl, g); }
            (h:having                   { setAny(select, "HAVING"_sl, h); }
            )? )?
        (o:orderBy y_                    { setAny(select, "ORDER_BY"_sl, o); }
            )?
        (
          LIMIT l:expression            { setAny(select, "LIMIT"_sl, l); }
          (OFFSET off:expression        { setAny(select, "OFFSET"_sl, off); }
             )?
          |
          OFFSET off:expression         { setAny(select, "OFFSET"_sl, off); }
          (LIMIT l:expression           { setAny(select, "LIMIT"_sl, l); }
             )?
        )?
        (y_ ';')?
                                        { $$ = select; }

selectResults =
    sr:selectResult                     { sr = arrayWith(sr); }
      (y_ ',' y_ sr2:selectResult         { appendAny(sr, sr2);  }
      )*                                { $$ = sr; }

selectResult =
    x:expression (y_ AS? ca:columnAlias )?
                                        { assert(!x.isNull());
                                          if (ca.isNull())
                                            $$ = x;
                                          else
                                            $$ = op("AS", x, ca); }

from =
    FROM d:dataSource                   { d = arrayWith(d);}
        (y_ j:join                       { appendAny(d, j);}
         )*                             { $$ = d;}

dataSource =
    n:collectionName                    { n = dictWithCollectionArray(n); }
		(AS? a:collectionAlias          { setAny(n, "AS"_sl, a); }
		)?                              { $$ = n; }

collectionName  =
    c:IDENTIFIER                        { c = arrayWith(c); }
        ('.' c2:IDENTIFIER              { appendAny(c, c2); }
        )?                              { $$ = c; }

join =
    o:joinOperator y_ s:dataSource y_     { setAny(s, "JOIN"_sl, o); }
        ( ON c:expression               { setAny(s, "ON"_sl, c); }
        )?                              { $$ = s; }

joinOperator =
    <( LEFT (OUTER)? | INNER | CROSS )?> JOIN
                                        { string join = trim(yytext);
                                          $$ = join.empty() ? string("INNER") : join;}

groupBy =
    GROUP BY x:expression               { x = arrayWith(x);}
        ( y_ ',' y_ x2:expression         { appendAny(x, x2);}
        )*                              { $$ = x;}

having =
    HAVING expression

orderBy =
    ORDER BY o:ordering                 { o = arrayWith(o); }
        ( y_ ',' y_ o2:ordering           { appendAny(o, o2); }
        )*                              { $$ = o; }

ordering =
    x:expression
        ( y_ o:order                     { x = op(o, x);}
        )?                              { $$ = x; }

order =
    <( ASC | DESC )>                    { $$ = trim(yytext);}

columnAlias     = IDENTIFIER
collectionAlias = IDENTIFIER
indexName       = IDENTIFIER


######## EXPRESSIONS:


expression =
    expr9


caseExpression =
    CASE (!WHEN val:expression)?        { val = op("CASE", (val.isNull() ? Any(nullValue) : val));}
    (WHEN when:expression THEN then:expression
                                        { appendAny(val, when);
                                          appendAny(val, then);
                                        }
        )+
    (ELSE elsex:expression              { appendAny(val, elsex);}
        )? END                          {  $$ = val; }


anyEveryExpression =
    a:anyEvery y_ v:variableName y_ IN y_ e:expression y_ SATISFIES y_ s:expression END
                                        { if (s.is<MutableArray>())
                                            substituteVariable(v, s);
                                          auto oper = op(a);
                                          appendAny(oper, v);
                                          appendAny(oper, e);
                                          appendAny(oper, s);
                                          $$ = oper; }
anyEvery =
    anyOrSome AND EVERY                 { $$ = string("ANY AND EVERY");}
  | anyOrSome                           { $$ = string("ANY");}
  | EVERY                               { $$ = string("EVERY");}

anyOrSome = ANY | SOME

variableName    = IDENTIFIER


######## BINARY (mostly) OPERATORS:


# Every level of operator precedence needs its own grammar rule, to ensure that operations
# are grouped correctly. The precedence levels here are taken from the SQLite documentation.
# Level 8 is the lowest, level 0 the highest.

POST_OP_PREC_6 =
    NOT NULL            { $$ = string("NOT NULL");}
  | IS NULL             { $$ = string("IS NULL");}
  | IS MISSING          { $$ = string("IS MISSING");}
  | IS VALUED           { $$ = string("IS VALUED");}
  | IS NOT NULL         { $$ = string("IS NOT NULL");}
  | IS NOT MISSING      { $$ = string("IS NOT MISSING");}
  | IS NOT VALUED       { $$ = string("IS NOT VALUED");}

expr9 =
    x:expr8 (
       y_ co:collateSuffix       { MutableArray coArray = co;
                                          bool did_collateOp = false;
                                          for (auto iter = coArray.begin(); iter != coArray.end(); ++iter) {
                                            if (did_collateOp) {
                                               extendCollate(x, iter->asstring());
                                            } else {
                                               x = collateOp(x, iter->asstring());
                                               did_collateOp = true;
                                            }
                                          }
                                }
       )?                       { $$ = x; }

expr8 =
    x:expr7 (y_ op:OP_PREC_8 y_ r:expr7   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr7 =
    x:expr6 (y_ op:OP_PREC_7 y_ r:expr6   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr6 =
    x:expr5 o:POST_OP_PREC_6            { $$ = op(o, x); }
  | inExpression
  | likeExpression
  | betweenExpression
  | x:expr5 (y_ o:OP_PREC_6 y_ r:expr5    { x = binaryOp(x, o, r);}
             )*                         { $$ = x}
expr5 =
    x:expr4 (y_ op:OP_PREC_5 y_ r:expr4   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr4 =
    x:expr3 (y_ op:OP_PREC_4 y_ r:expr3   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr3 =
    x:expr2 (y_ op:OP_PREC_3 y_ r:expr2   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}
expr2 =
    x:expr1 (y_ op:OP_PREC_2 y_ r:expr1   { x = binaryOp(x, op, r); }
             )*                         { $$ = x}
expr1 =
    x:expr0 (y_ op:OP_PREC_1 y_ r:expr0   { x = binaryOp(x, op, r);}
             )*                         { $$ = x}

likeExpression =
    x:expr5 y_ (n:NOT)? LIKE r:expr5     { auto b = binaryOp(x, "LIKE", r);
                                          if (n.isNotNull())  b = op("NOT", b);
                                          $$ = b; }

betweenExpression =
    x:expr5 (n:NOT)? BETWEEN min:expr5 AND max:expr5
                                        { auto b = op("BETWEEN", x, min, max);
                                          if (n.isNotNull())  b = op("NOT", b);
                                          $$ = b; }

OP_PREC_8 = OR                          { $$ = string("OR");}
OP_PREC_7 = AND                         { $$ = string("AND");}
OP_PREC_6 = ('=='|'=')                  { $$ = string("=");}
          | ('<>'|'!=')                 { $$ = string("!=");}
          | (IS NOT)                    { $$ = string("IS NOT");}
          | IS                          { $$ = string("IS");}
OP_PREC_5 = <('<='|'<'|'>='|'>')>       { $$ = trim(yytext);}
OP_PREC_4 = <('<<'|'>>'|'&'|'|')>       { $$ = trim(yytext);}
OP_PREC_3 = <[-+]>                      { $$ = trim(yytext);}
OP_PREC_2 = <[*/%]>                     { $$ = trim(yytext);}
OP_PREC_1 = <'||'>                      { $$ = trim(yytext);}


######## IN and NOT IN:


inExpression =
    x:expr5 i:IN_OR_NOT
        (s:selectExpr                  &{false} # TODO: Support in LiteCore   { $$ = op(i, x, s); }
        | p:parenExprs                  { $$ = op(i, x, insertAny(p, 0, string("[]"))); }
        | a:arrayLiteral                { $$ = op(i, x, a); }
        )

IN_OR_NOT =
    NOT IN                              { $$ = string("NOT IN");}
  | IN                                  { $$ = string("IN");}

selectExpr =
    '(' s:selectStatement ')'           { $$ = op("SELECT", s); }


######## HIGHEST-PRIORITY EXPRESSIONS:


expr0 =
    x:baseExpr '.' p:propertyPath       { $$ = op("_.", x, p);}
  | x:baseExpr                          { $$ = x; }

collateSuffix =
    co:COLLATE                          { co = Any(); }
    (
        c:collation y_ !collation        { co = arrayWith(c); }
      | '(' y_
        ( c:collation y_                 { if (co.isNull()) {
                                            co = arrayWith(c);
                                          } else {
                                            appendAny(co, c);
                                          } }
        )+ ')' y_
    )                                   { $$ = co; }

collationLang =
    <"NOUNICODE"i>                      { $$ = string(yytext); }
  | (
        "UNICODE"i                      { $$ = string("UNICODE"); }
        <(':' [a-zA-Z] [a-zA-Z0-9_]*)?> { $$ = $$.as<string>() + string(yytext); }
    )

collation =
  l:collationLang y_                    { $$ = l; }
  | <("NO"i? ("CASE"i | "DIAC"i)> WB)  { $$ = string(yytext); }

baseExpr_ =
    literal
  | arrayLiteral
  | dictLiteral
  | o:OP_PREFIX y_ r:baseExpr            { $$ = unaryOp(o, r);}
  | EXISTS s:selectExpr                 { $$ = op("EXISTS", s); }
  | caseExpression
  | anyEveryExpression
  | '$' IDENTIFIER                      { $$ = op(string("$") + yytext); }
  | function
  | property
  | '(' y_ expression y_ ')'
baseExpr = baseExpr_ y_                  # baseExpr to absorb all trailing white space

OP_PREFIX =
    <('-'|'+'|NOT)>                     { $$ = trim(yytext);}


######## PROPERTIES:


property =
    '*'                                 { $$ = op(".");}
  | a:collectionAlias '.' y_ '*'         { $$ = op("." + a.as<string>() + ".");}
  | p:propertyPath                      { $$ = op(p);}

propertyPath =
    p:propertyName                      { p = quoteProperty(p); }
        (('.' y_ p2:propertyName         { p = concatProperty(p, p2);}
         ) |
         ('[' y_ i:INT_LITERAL y_ ']' y_   { p = concatIndex(p, i);}
         )
        )*                              { $$ = p;}

propertyName
    = IDENTIFIER

indexTable =                            { a = string(""); }
    (a:collectionAlias y_ '.' y_ )?
    i:indexName                         { string c = a.as<string>();
                                          $$ = c.empty() ? i.as<string>() : c + "." + i.as<string>();
                                        }

######## FUNCTIONS:


function =
    "meta"i y_ '(' y_                    { f = op("meta()");}
    (c:IDENTIFIER y_                    { appendAny(f, c.as<string>());}
    )? ')' y_                           { $$ = f;}
  | "match"i y_ '(' y_                   { f = op("MATCH()");}
    ind:indexTable y_ ',' y_             { appendAny(f, ind.as<string>());}
    t:expression y_                     { appendAny(f, t);}
    ')' y_                              { $$ = f;}
  | "rank"i y_ '(' y_                    { f = op("RANK()");}
    ind:indexTable y_                   { appendAny(f, ind.as<string>());}
    ')' y_                              { $$ = f;}
  | f:functionName e:parenExprs        { $$ = insertAny(e, 0, f.as<string>() + "()");}

functionName    =
    IDENTIFIER                         &{isFunction(yytext)}

parenExprs =
    f:y_ '(' y_                           { f = MutableArray::newArray();}
        ( e:expression                  { appendAny(f, e);}
        (',' y_ e2:expression            { appendAny(f, e2);}
        )* )? ')'                       { $$ = f;}


######## IDENTIFIERS & KEYWORDS:


# In N1QL, unlike SQL, `"` delimits a string, while "`" is used to quote identifiers.
IDENTIFIER =
  <[a-zA-Z_] [a-zA-Z0-9_$]*>           &{!isReservedWord(yytext)}
        y_                               { $$ = string(yytext);}
  | "`"  <( [^`] | "``"   )*> "`"  y_    { $$ = unquote(yytext, '`');}


# Note: the 'i' suffix on strings makes them case-insensitive.
# This feature is not in the stock peg-1.1.8 distribution, but is in the one on Github.

ALL       = "ALL"i         WB
AND       = "AND"i         WB
ANY       = "ANY"i         WB
AS        = "AS"i          WB
ASC       = "ASC"i         WB
BETWEEN   = "BETWEEN"i     WB
BY        = "BY"i          WB
CASE      = "CASE"i        WB
COLLATE   = "COLLATE"i     WB
CROSS     = "CROSS"i       WB
DESC      = "DESC"i        WB
DISTINCT  = "DISTINCT"i    WB
ELSE      = "ELSE"i        WB
END       = "END"i         WB
EVERY     = "EVERY"i       WB
EXISTS    = "EXISTS"i      WB
FALSE     = "FALSE"i       WB
FROM      = "FROM"i        WB
GROUP     = "GROUP"i       WB
HAVING    = "HAVING"i      WB
IN        = "IN"i          WB
INNER     = "INNER"i       WB
IS        = "IS"i          WB
JOIN      = "JOIN"i        WB
LEFT      = "LEFT"i        WB
LIKE      = "LIKE"i        WB
LIMIT     = "LIMIT"i       WB
MISSING   = "MISSING"i     WB
NOT       = "NOT"i         WB
NULL      = "NULL"i        WB
OFFSET    = "OFFSET"i      WB
ON        = "ON"i          WB
OR        = "OR"i          WB
ORDER     = "ORDER"i       WB
OUTER     = "OUTER"i       WB
SATISFIES = "SATISFIES"i   WB
SELECT    = "SELECT"i      WB
SOME      = "SOME"i        WB
THEN      = "THEN"i        WB
TRUE      = "TRUE"i        WB
VALUED    = "VALUED"i      WB
WHEN      = "WHEN"i        WB
WHERE     = "WHERE"i       WB


######## COMPOUND LITERALS:


arrayLiteral =
    '[' y_ (
        e:expression                    { e = op("[]", e); }
        ( y_ ',' y_ e2:expression         { appendAny(e, e2); }
         )*
    )? ']'                              { $$ = e.isNull() ? Any(op("[]")) : e;}


dictLiteral =
    '{' y_ (
        k:STRING_LITERAL ':' y_ e:expression           { e = dictWith(slice(k.as<string>()), e); }
        ( y_ ',' y_ k:STRING_LITERAL ':' y_ v:expression { setAny(e, slice(k.as<string>()), v); }
         )*
    )? '}'                              { $$ = e.isNull() ? Any(MutableDict::newDict()) : e;}


######## LITERALS:


literal =
    FLOAT_LITERAL
  | INT_LITERAL
  | BOOLEAN_LITERAL
  | STRING_LITERAL
  | NULL                                { $$ = nullValue; }
  | MISSING                             { $$ = op("MISSING");}

BOOLEAN_LITERAL =
    TRUE                                { $$ = true;}
  | FALSE                               { $$ = false;}

FLOAT_LITERAL =
    <'-'? (('.' DIGIT+) | (DIGIT+ (('.' DIGIT*)) ( [Ee] [-+]? DIGIT+ )? | (DIGIT+ ( [Ee] [-+]? DIGIT+ ))))> WB
                                        { double d;
                                          sscanf(yytext, "%lf", &d);
                                          $$ = d; }
INT_LITERAL =
    <'-'? DIGIT+> WB                    { $$ = (long long)atoll(yytext);}

DIGIT = [0-9]


# In N1QL, unlike SQL, strings can be double-quoted as well as single-quoted.
STRING_LITERAL =
    "'" <( [^'] | "''" )*> "'" y_        { $$ = unquote(yytext, '\'');}
  | "\"" <( [^"] | "\"\"" )*> "\"" y_    { $$ = unquote(yytext, '"');}


WB = ![a-zA-Z0-9_] y_       # Word break + optional whitespace
y_  = [ \t\r\n]*            # Optional whitespace


%%
//////// PARSER ENTRY POINT (C++):


#undef __

const char kN1QLEND = '\0';

static int n1ql_input(yycontext *ctx, char *buf, size_t max_size) {
    ctx->stream->get(buf, max_size, kN1QLEND);
    return (int) ctx->stream->gcount();
}


FLMutableDict parse(const string &input, unsigned *errPos) {
    MutableDict result;
    std::stringstream stream(input, std::ios_base::in);
    yycontext ctx = { };
    ctx.stream = &stream;

    bool ok = parse(&ctx) != 0;
    if (ok) {
        result = ctx._;
    } else {
        *errPos = (unsigned) ctx._maxpos;
    }
    yyrelease(&ctx);
    return (FLMutableDict) FLValue_Retain(result);
}

} }
