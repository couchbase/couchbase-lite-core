//
// SQLiteKeyStore+ArrayIndexes.cc
//
// Copyright 2018-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#include "SQLiteKeyStore.hh"
#include "SQLiteDataFile.hh"
#include "QueryParser.hh"
#include "SQLUtil.hh"
#include "StringUtil.hh"
#include "SQLiteCpp/SQLiteCpp.h"
#include "Array.hh"

using namespace std;
using namespace fleece;
using namespace fleece::impl;

namespace litecore {

    bool SQLiteKeyStore::createArrayIndex(const IndexSpec& spec) {
        Array::iterator iExprs(spec.what());
        string          arrayTableName = createUnnestedTable(iExprs.value(), spec.optionsPtr());
        return createIndex(spec, arrayTableName, ++iExprs);
    }

    string SQLiteKeyStore::createUnnestedTable(const Value* expression, const IndexSpec::Options* options) {
        // Derive the table name from the expression it unnests:
        string      kvTableName = tableName();
        QueryParser qp(db(), "", kvTableName);
        string      unnestTableName = qp.unnestedTableName(expression);

        // Create the index table, unless an identical one already exists:
        string sql = CONCAT("CREATE TABLE " << sqlIdentifier(unnestTableName)
                                            << " "
                                               "(docid INTEGER NOT NULL REFERENCES "
                                            << sqlIdentifier(kvTableName)
                                            << "(rowid), "
                                               " i INTEGER NOT NULL,"
                                               " body BLOB NOT NULL, "
                                               " CONSTRAINT pk PRIMARY KEY (docid, i)) "
                                               "WITHOUT ROWID");
        if ( !db().schemaExistsWithSQL(unnestTableName, "table", unnestTableName, sql) ) {
            LogTo(QueryLog, "Creating UNNEST table '%s' on %s", unnestTableName.c_str(),
                  expression->toJSON(true).asString().c_str());
            db().exec(sql);

            qp.setBodyColumnName("new.body");
            string eachExpr = qp.eachExpressionSQL(expression);

            // Populate the index-table with data from existing documents:
            db().exec(CONCAT("INSERT INTO " << sqlIdentifier(unnestTableName)
                                            << " (docid, i, body) "
                                               "SELECT new.rowid, _each.rowid, _each.value "
                                            << "FROM " << sqlIdentifier(kvTableName) << " as new, " << eachExpr
                                            << " AS _each "
                                               "WHERE (new.flags & 1) = 0"));

            // Set up triggers to keep the index-table up to date
            // ...on insertion:
            string insertTriggerExpr = CONCAT("INSERT INTO " << sqlIdentifier(unnestTableName)
                                                             << " (docid, i, body) "
                                                                "SELECT new.rowid, _each.rowid, _each.value "
                                                             << "FROM " << eachExpr << " AS _each ");
            createTrigger(unnestTableName, "ins", "AFTER INSERT", "WHEN (new.flags & 1) = 0", insertTriggerExpr);

            // ...on delete:
            string deleteTriggerExpr = CONCAT("DELETE FROM " << sqlIdentifier(unnestTableName)
                                                             << " "
                                                                "WHERE docid = old.rowid");
            createTrigger(unnestTableName, "del", "BEFORE DELETE", "WHEN (old.flags & 1) = 0", deleteTriggerExpr);

            // ...on update:
            createTrigger(unnestTableName, "preupdate", "BEFORE UPDATE OF body, flags", "WHEN (old.flags & 1) = 0",
                          deleteTriggerExpr);
            createTrigger(unnestTableName, "postupdate", "AFTER UPDATE OF body, flags", "WHEN (new.flags & 1 = 0)",
                          insertTriggerExpr);
        }
        return unnestTableName;
    }

}  // namespace litecore
