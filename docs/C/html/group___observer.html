<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteCore: Database, Document, Query Observers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LiteCore
   </div>
   <div id="projectbrief">Couchbase Lite cross-platform core implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">Database, Document, Query Observers</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a change to a document in a collection, as returned from <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges</a>.  <a href="struct_c4_collection_change.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c4_collection_observation.html">C4CollectionObservation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold the results of a call to <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges</a>.  <a href="struct_c4_collection_observation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Collection Observer</h2></td></tr>
<tr class="memitem:ga1a4e9d32cb3fc53098f1e8bed57cb629"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#ga1a4e9d32cb3fc53098f1e8bed57cb629">C4DatabaseChange</a></td></tr>
<tr class="separator:ga1a4e9d32cb3fc53098f1e8bed57cb629"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Collection Observer</h2></td></tr>
<tr class="memitem:ga5c70a4dd1c29ad86859bf29b471b2a9f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#ga5c70a4dd1c29ad86859bf29b471b2a9f">C4CollectionObserverCallback</a>) (<a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> *observer, void *context)</td></tr>
<tr class="memdesc:ga5c70a4dd1c29ad86859bf29b471b2a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked by a collection/database observer.  <br /></td></tr>
<tr class="separator:ga5c70a4dd1c29ad86859bf29b471b2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e7cdcb727099df8ca243176f2caf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gab8e7cdcb727099df8ca243176f2caf82">c4dbobs_createOnCollection</a> (<a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *collection, <a class="el" href="group___observer.html#ga5c70a4dd1c29ad86859bf29b471b2a9f">C4CollectionObserverCallback</a> callback, void *context, <a class="el" href="struct_c4_error.html">C4Error</a> *error)</td></tr>
<tr class="memdesc:gab8e7cdcb727099df8ca243176f2caf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new collection observer, with a callback that will be invoked after one or more documents in the collection have changed.  <br /></td></tr>
<tr class="separator:gab8e7cdcb727099df8ca243176f2caf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69dff733bc5255726205352dee6b10c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="struct_c4_collection_observation.html">C4CollectionObservation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges</a> (<a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> *observer, <a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a> outChanges[], uint32_t maxChanges)</td></tr>
<tr class="memdesc:ga69dff733bc5255726205352dee6b10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies which documents have changed in the collection since the last time this function was called, or since the observer was created.  <br /></td></tr>
<tr class="separator:ga69dff733bc5255726205352dee6b10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7d028f0bdf5c7409bfe4c8fde84b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gadf7d028f0bdf5c7409bfe4c8fde84b89">c4dbobs_releaseChanges</a> (<a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a> changes[], uint32_t numChanges)</td></tr>
<tr class="memdesc:gadf7d028f0bdf5c7409bfe4c8fde84b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the memory used by the <code><a class="el" href="struct_c4_collection_change.html" title="Represents a change to a document in a collection, as returned from c4dbobs_getChanges.">C4CollectionChange</a></code> structs (to hold the docID and revID strings.) This must be called after <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges()</a>.  <br /></td></tr>
<tr class="separator:gadf7d028f0bdf5c7409bfe4c8fde84b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Document Observer</h2></td></tr>
<tr class="memitem:ga89ca8018d3641e08bc06b986aea8fae8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#ga89ca8018d3641e08bc06b986aea8fae8">C4DocumentObserverCallback</a>) (<a class="el" href="group___base.html#ga8a4ef01035322ff935bae1ea30a9199e">C4DocumentObserver</a> *observer, <a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *collection, <a class="el" href="group___base.html#ga04de3d84e73df3c8b75092054abcc117">C4String</a> docID, <a class="el" href="group___base.html#ga6c2d959939ef287ba3f2ee719c949229">C4SequenceNumber</a> sequence, void *context)</td></tr>
<tr class="memdesc:ga89ca8018d3641e08bc06b986aea8fae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked by a document observer.  <br /></td></tr>
<tr class="separator:ga89ca8018d3641e08bc06b986aea8fae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36cdc6bc54392d47a3853359df999bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga8a4ef01035322ff935bae1ea30a9199e">C4DocumentObserver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#ga36cdc6bc54392d47a3853359df999bf0">c4docobs_createWithCollection</a> (<a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *collection, <a class="el" href="group___base.html#ga04de3d84e73df3c8b75092054abcc117">C4String</a> docID, <a class="el" href="group___observer.html#ga89ca8018d3641e08bc06b986aea8fae8">C4DocumentObserverCallback</a> callback, void *context, <a class="el" href="struct_c4_error.html">C4Error</a> *error)</td></tr>
<tr class="memdesc:ga36cdc6bc54392d47a3853359df999bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new document observer, with a callback that will be invoked when the document changes.  <br /></td></tr>
<tr class="separator:ga36cdc6bc54392d47a3853359df999bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Query Observer</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>A query observer, also called a "live query", notifies the client when the query's result set changes.</p>
<p>(Not just any time the database changes.)</p>
<p>This is done as follows, starting from when the first time an observer on a particular query is enabled:</p>
<ol type="1">
<li>A separate C4Query instance is created, on a separate database instance (there's one of these background database instances per C4Database.)</li>
<li>The copied query is run on a background thread, and it saves its results.</li>
<li>The query observer(s) are notified so they can see the initial results.</li>
<li>The background thread listens for changes to the database, <em>or</em> changes to the query parameters (<a class="el" href="group___querying_d_b.html#ga82dbdfa68b124e92704893f4730ce7d2">c4query_setParameters</a>). In response:<ul>
<li>If it's been less than 250ms since the last time it ran the query, it first waits 500ms; during this time it ignores further database changes.</li>
<li>It runs the query.</li>
<li>It compares the new result set to the old one; if they're different, it saves the new results and notifies observers. Otherwise it does nothing.</li>
</ul>
</li>
<li>This background task stops when the last observer is disabled.</li>
</ol>
<p>Some notes on performance:</p>
<p>All C4Queries on a single C4Database share a single background C4Database, which can only do one thing at a time. That means multiple live queries can bog down since they have to run one after the other. The first time any query observer is added in a given <em>C4Database</em>, the background database instance has to be opened, which takes a few milliseconds. The first time an observer is added to a C4Query, a copy of that query has to be created and compiled by the background database, which can also take a few millseconds. Running a C4Query before adding an observer is a bit of a waste, because the query will be run twice. It's more efficient to skip running it, and instead wait for the first call to the observer. The timing logic in step 4 is a heuristic to provide low latency on occasional database changes, but prevent rapid database changes (as happen during pull replication) from running the query constantly and/or spamming observers with notifications. (The specific times are not currently alterable; they're constants in LiveQuerier.cc.) </p>
</td></tr>
<tr class="memitem:gad4ae536243b44f5e79c0de373318c22d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gad4ae536243b44f5e79c0de373318c22d">C4QueryObserverCallback</a>) (<a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *observer, <a class="el" href="group___base.html#ga67aedbf60fd71b8727d6d0ca9bd339ca">C4Query</a> *query, void *context)</td></tr>
<tr class="memdesc:gad4ae536243b44f5e79c0de373318c22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked by a query observer, notifying that the query results have changed.  <br /></td></tr>
<tr class="separator:gad4ae536243b44f5e79c0de373318c22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa378c5c9c0a04616c802967c32d7c4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gaa378c5c9c0a04616c802967c32d7c4a8">c4queryobs_create</a> (<a class="el" href="group___base.html#ga67aedbf60fd71b8727d6d0ca9bd339ca">C4Query</a> *query, <a class="el" href="group___observer.html#gad4ae536243b44f5e79c0de373318c22d">C4QueryObserverCallback</a> callback, void *context)</td></tr>
<tr class="memdesc:gaa378c5c9c0a04616c802967c32d7c4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new query observer, with a callback that will be invoked when the query results change, with an enumerator containing the new results.  <br /></td></tr>
<tr class="separator:gaa378c5c9c0a04616c802967c32d7c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a79c5ba0b4165010c22b6b3218f58d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gaa9a79c5ba0b4165010c22b6b3218f58d">c4queryobs_setEnabled</a> (<a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *obs, bool enabled)</td></tr>
<tr class="memdesc:gaa9a79c5ba0b4165010c22b6b3218f58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a query observer so its callback can be called, or disables it to stop callbacks.  <br /></td></tr>
<tr class="separator:gaa9a79c5ba0b4165010c22b6b3218f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb7a2d0b36b83bc782117d58d32785e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="struct_c4_query_enumerator.html">C4QueryEnumerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___observer.html#gaaeb7a2d0b36b83bc782117d58d32785e">c4queryobs_getEnumerator</a> (<a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *obs, bool forget, <a class="el" href="struct_c4_error.html">C4Error</a> *error)</td></tr>
<tr class="memdesc:gaaeb7a2d0b36b83bc782117d58d32785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current query results, if any.  <br /></td></tr>
<tr class="separator:gaaeb7a2d0b36b83bc782117d58d32785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5c70a4dd1c29ad86859bf29b471b2a9f" name="ga5c70a4dd1c29ad86859bf29b471b2a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c70a4dd1c29ad86859bf29b471b2a9f">&#9670;&#160;</a></span>C4CollectionObserverCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* C4CollectionObserverCallback) (<a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> *observer, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked by a collection/database observer. </p>
<p>CAUTION: This callback is called when a transaction is committed, even one made by a different connection (C4Database instance) on the same file. This means that, if your application is multithreaded, the callback may be running on a different thread than the one this database instance uses. It is your responsibility to ensure thread safety.</p>
<p>In general, it is best to make <em>no</em> LiteCore calls from within this callback. Instead, use your platform event-handling API to schedule a later call from which you can read the changes. Since this callback may be invoked many times in succession, make sure you schedule only one call at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer that initiated the callback. </td></tr>
    <tr><td class="paramname">context</td><td>user-defined parameter given when registering the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a4e9d32cb3fc53098f1e8bed57cb629" name="ga1a4e9d32cb3fc53098f1e8bed57cb629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4e9d32cb3fc53098f1e8bed57cb629">&#9670;&#160;</a></span>C4DatabaseChange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a> <a class="el" href="group___observer.html#ga1a4e9d32cb3fc53098f1e8bed57cb629">C4DatabaseChange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga89ca8018d3641e08bc06b986aea8fae8" name="ga89ca8018d3641e08bc06b986aea8fae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ca8018d3641e08bc06b986aea8fae8">&#9670;&#160;</a></span>C4DocumentObserverCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* C4DocumentObserverCallback) (<a class="el" href="group___base.html#ga8a4ef01035322ff935bae1ea30a9199e">C4DocumentObserver</a> *observer, <a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *collection, <a class="el" href="group___base.html#ga04de3d84e73df3c8b75092054abcc117">C4String</a> docID, <a class="el" href="group___base.html#ga6c2d959939ef287ba3f2ee719c949229">C4SequenceNumber</a> sequence, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked by a document observer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer that initiated the callback. </td></tr>
    <tr><td class="paramname">docID</td><td>The ID of the document that changed. </td></tr>
    <tr><td class="paramname">sequence</td><td>The sequence number of the change. </td></tr>
    <tr><td class="paramname">context</td><td>user-defined parameter given when registering the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4ae536243b44f5e79c0de373318c22d" name="gad4ae536243b44f5e79c0de373318c22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ae536243b44f5e79c0de373318c22d">&#9670;&#160;</a></span>C4QueryObserverCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* C4QueryObserverCallback) (<a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *observer, <a class="el" href="group___base.html#ga67aedbf60fd71b8727d6d0ca9bd339ca">C4Query</a> *query, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked by a query observer, notifying that the query results have changed. </p>
<p>The actual enumerator is not passed to the callback, but can be retrieved by calling <a class="el" href="group___observer.html#gaaeb7a2d0b36b83bc782117d58d32785e">c4queryobs_getEnumerator</a>. </p><dl class="section warning"><dt>Warning</dt><dd>This function is called on a random background thread! Be careful of thread safety. Do not spend too long in this callback or other observers may be delayed. It's best to do nothing except schedule a call on your preferred thread/queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer triggering the callback. </td></tr>
    <tr><td class="paramname">query</td><td>The C4Query that the observer belongs to. </td></tr>
    <tr><td class="paramname">context</td><td>The <code>context</code> parameter you passed to <a class="el" href="group___observer.html#gaa378c5c9c0a04616c802967c32d7c4a8">c4queryobs_create</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab8e7cdcb727099df8ca243176f2caf82" name="gab8e7cdcb727099df8ca243176f2caf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e7cdcb727099df8ca243176f2caf82">&#9670;&#160;</a></span>c4dbobs_createOnCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> * c4dbobs_createOnCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___observer.html#ga5c70a4dd1c29ad86859bf29b471b2a9f">C4CollectionObserverCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c4_error.html">C4Error</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new collection observer, with a callback that will be invoked after one or more documents in the collection have changed. </p>
<p>This is exactly like c4dbobs_create, except that it acts on any collection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection to observe. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call after the collection changes. </td></tr>
    <tr><td class="paramname">context</td><td>An arbitrary value that will be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new observer reference. </dd></dl>

</div>
</div>
<a id="ga69dff733bc5255726205352dee6b10c6" name="ga69dff733bc5255726205352dee6b10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69dff733bc5255726205352dee6b10c6">&#9670;&#160;</a></span>c4dbobs_getChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="struct_c4_collection_observation.html">C4CollectionObservation</a> c4dbobs_getChanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#ga6ee85db00f1ffcf03308ef5350855e29">C4CollectionObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a>&#160;</td>
          <td class="paramname"><em>outChanges</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxChanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies which documents have changed in the collection since the last time this function was called, or since the observer was created. </p>
<p>This function effectively "reads" changes from a stream, in whatever quantity the caller desires. Once all of the changes have been read, the observer is reset and ready to notify again.</p>
<p>This function is usually called in response to your <code>C4CollectionObserverCallback</code> being called, but it doesn't have to be; it can be called at any time (subject to thread-safety requirements, of course.)</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this function, you must call <a class="el" href="group___observer.html#gadf7d028f0bdf5c7409bfe4c8fde84b89">c4dbobs_releaseChanges</a> to release memory that's being referenced by the <code><a class="el" href="struct_c4_collection_change.html" title="Represents a change to a document in a collection, as returned from c4dbobs_getChanges.">C4CollectionChange</a></code>s.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer. </td></tr>
    <tr><td class="paramname">outChanges</td><td>A caller-provided buffer of structs into which changes will be written. </td></tr>
    <tr><td class="paramname">maxChanges</td><td>The maximum number of changes to return, i.e. the size of the caller's outChanges buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Common information about the changes contained in outChanges (number of changes, external vs non-external, and the relevant collection) </dd></dl>

</div>
</div>
<a id="gadf7d028f0bdf5c7409bfe4c8fde84b89" name="gadf7d028f0bdf5c7409bfe4c8fde84b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf7d028f0bdf5c7409bfe4c8fde84b89">&#9670;&#160;</a></span>c4dbobs_releaseChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> void c4dbobs_releaseChanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c4_collection_change.html">C4CollectionChange</a>&#160;</td>
          <td class="paramname"><em>changes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numChanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the memory used by the <code><a class="el" href="struct_c4_collection_change.html" title="Represents a change to a document in a collection, as returned from c4dbobs_getChanges.">C4CollectionChange</a></code> structs (to hold the docID and revID strings.) This must be called after <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">changes</td><td>The same array of changes that was passed to <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges</a>. </td></tr>
    <tr><td class="paramname">numChanges</td><td>The number of changes returned by <a class="el" href="group___observer.html#ga69dff733bc5255726205352dee6b10c6">c4dbobs_getChanges</a>, i.e. the number of valid items in <code>changes</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36cdc6bc54392d47a3853359df999bf0" name="ga36cdc6bc54392d47a3853359df999bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36cdc6bc54392d47a3853359df999bf0">&#9670;&#160;</a></span>c4docobs_createWithCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga8a4ef01035322ff935bae1ea30a9199e">C4DocumentObserver</a> * c4docobs_createWithCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#gad8be2ad2cef903785ae3f9736e14253b">C4Collection</a> *&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___base.html#ga04de3d84e73df3c8b75092054abcc117">C4String</a>&#160;</td>
          <td class="paramname"><em>docID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___observer.html#ga89ca8018d3641e08bc06b986aea8fae8">C4DocumentObserverCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c4_error.html">C4Error</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new document observer, with a callback that will be invoked when the document changes. </p>
<dl class="section note"><dt>Note</dt><dd>This is exactly like c4docobs_create, except that it works on any collection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection containing the document to observe. </td></tr>
    <tr><td class="paramname">docID</td><td>The ID of the document to observe. </td></tr>
    <tr><td class="paramname">callback</td><td>The function to call after the database changes. </td></tr>
    <tr><td class="paramname">context</td><td>An arbitrary value that will be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new observer reference. </dd></dl>

</div>
</div>
<a id="gaa378c5c9c0a04616c802967c32d7c4a8" name="gaa378c5c9c0a04616c802967c32d7c4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa378c5c9c0a04616c802967c32d7c4a8">&#9670;&#160;</a></span>c4queryobs_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> * c4queryobs_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#ga67aedbf60fd71b8727d6d0ca9bd339ca">C4Query</a> *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___observer.html#gad4ae536243b44f5e79c0de373318c22d">C4QueryObserverCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new query observer, with a callback that will be invoked when the query results change, with an enumerator containing the new results. </p>
<dl class="section note"><dt>Note</dt><dd>The callback isn't invoked immediately after a change, and won't be invoked after every change, to avoid performance problems. Instead, there's a brief delay so multiple changes can be coalesced. </dd>
<dd>
The new observer needs to be enabled by calling <a class="el" href="group___observer.html#gaa9a79c5ba0b4165010c22b6b3218f58d">c4queryobs_setEnabled</a>. </dd></dl>

</div>
</div>
<a id="gaaeb7a2d0b36b83bc782117d58d32785e" name="gaaeb7a2d0b36b83bc782117d58d32785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb7a2d0b36b83bc782117d58d32785e">&#9670;&#160;</a></span>c4queryobs_getEnumerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> <a class="el" href="struct_c4_query_enumerator.html">C4QueryEnumerator</a> * c4queryobs_getEnumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c4_error.html">C4Error</a> *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current query results, if any. </p>
<p>When the observer is created, the results are initially NULL until the query finishes running in the background. Once the observer callback is called, the results are available. </p><dl class="section note"><dt>Note</dt><dd>You are responsible for releasing the returned reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obs</td><td>The query observer. </td></tr>
    <tr><td class="paramname">forget</td><td>If true, the observer will not hold onto the enumerator, and subsequent calls will return NULL until the next time the observer notifies you. This can help conserve memory, since the query result data will be freed as soon as you release the enumerator. </td></tr>
    <tr><td class="paramname">error</td><td>If the last evaluation of the query failed, the error will be stored here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current query results, or NULL if the query hasn't run or has failed. </dd></dl>

</div>
</div>
<a id="gaa9a79c5ba0b4165010c22b6b3218f58d" name="gaa9a79c5ba0b4165010c22b6b3218f58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9a79c5ba0b4165010c22b6b3218f58d">&#9670;&#160;</a></span>c4queryobs_setEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="c4_compat_8h.html#a172b88317c4e1248e156ca77731f1650">CBL_CORE_API</a> void c4queryobs_setEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___base.html#ga89a77eddf7600ce9e9e17933e8ef8a75">C4QueryObserver</a> *&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables a query observer so its callback can be called, or disables it to stop callbacks. </p>
<p>When a query observer is enabled, its callback will be called with the current results. If this is the first observer, the query has to run first (on a background thread) so the callback will take a little while; if there are already enabled observers, the callback will be pretty much instantaneous. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
