<!--
Copyright 2021-Present Couchbase, Inc.
Use of this software is governed by the Business Source License included in
the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
file, in accordance with the Business Source License, use of this software will
be governed by the Apache License, Version 2.0, included in the file
licenses/APL2.txt.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteCore: Slices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LiteCore
   </div>
   <div id="projectbrief">Couchbase Lite cross-platform core implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Slices</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_l_slice.html">FLSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple reference to a block of memory.  <a href="struct_f_l_slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A heap-allocated block of memory returned from an API call.  <a href="struct_f_l_slice_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5445a97beaea63c3eadb1427c3a717d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga5445a97beaea63c3eadb1427c3a717d8">kFLSliceNull</a>&#160;&#160;&#160;((<a class="el" href="struct_f_l_slice.html">FLSlice</a>){NULL, 0})</td></tr>
<tr class="memdesc:ga5445a97beaea63c3eadb1427c3a717d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient constant denoting a null slice.  <a href="#ga5445a97beaea63c3eadb1427c3a717d8">More...</a><br /></td></tr>
<tr class="separator:ga5445a97beaea63c3eadb1427c3a717d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e82def46e214a706216353705768453"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga0e82def46e214a706216353705768453">FLSTR</a>(STR)&#160;&#160;&#160;((<a class="el" href="struct_f_l_slice.html">FLSlice</a>){(&quot;&quot; STR), sizeof((&quot;&quot; STR))-1})</td></tr>
<tr class="memdesc:ga0e82def46e214a706216353705768453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro version of <a class="el" href="group___f_l_slice.html#gae9d0af13963246fd37fbf16c4b237f53">FLStr</a>, for use in initializing compile-time constants.  <a href="#ga0e82def46e214a706216353705768453">More...</a><br /></td></tr>
<tr class="separator:ga0e82def46e214a706216353705768453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabc10b138e3c1345a4396b39c11a1f0d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gabc10b138e3c1345a4396b39c11a1f0d5">FLHeapSlice</a></td></tr>
<tr class="memdesc:gabc10b138e3c1345a4396b39c11a1f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A heap-allocated, reference-counted slice.  <a href="#gabc10b138e3c1345a4396b39c11a1f0d5">More...</a><br /></td></tr>
<tr class="separator:gabc10b138e3c1345a4396b39c11a1f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab0e7979cf6c99ffe836e84e55b6c76"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gabab0e7979cf6c99ffe836e84e55b6c76">FLString</a></td></tr>
<tr class="separator:gabab0e7979cf6c99ffe836e84e55b6c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08438b1f08efeefe09ece8079734fdd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gab08438b1f08efeefe09ece8079734fdd">FLStringResult</a></td></tr>
<tr class="separator:gab08438b1f08efeefe09ece8079734fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae9d0af13963246fd37fbf16c4b237f53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gae9d0af13963246fd37fbf16c4b237f53">FLStr</a> (const char *str)</td></tr>
<tr class="memdesc:gae9d0af13963246fd37fbf16c4b237f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice pointing to the contents of a C string.  <a href="#gae9d0af13963246fd37fbf16c4b237f53">More...</a><br /></td></tr>
<tr class="separator:gae9d0af13963246fd37fbf16c4b237f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b5777450a091e1cecb4d1ff36c0a23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga23b5777450a091e1cecb4d1ff36c0a23">FLSlice_Equal</a> (<a class="el" href="struct_f_l_slice.html">FLSlice</a> a, <a class="el" href="struct_f_l_slice.html">FLSlice</a> b) <a class="el" href="_base_8h.html#aaf76422cb887897c286992499106254d">FLPURE</a></td></tr>
<tr class="memdesc:ga23b5777450a091e1cecb4d1ff36c0a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality test of two slices.  <a href="#ga23b5777450a091e1cecb4d1ff36c0a23">More...</a><br /></td></tr>
<tr class="separator:ga23b5777450a091e1cecb4d1ff36c0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa284d9d65b1d25e3284c33ce451e555c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gaa284d9d65b1d25e3284c33ce451e555c">FLSlice_Compare</a> (<a class="el" href="struct_f_l_slice.html">FLSlice</a>, <a class="el" href="struct_f_l_slice.html">FLSlice</a>) <a class="el" href="_base_8h.html#aaf76422cb887897c286992499106254d">FLPURE</a></td></tr>
<tr class="memdesc:gaa284d9d65b1d25e3284c33ce451e555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of two slices; basically like memcmp(), but taking into account differences in length.  <a href="#gaa284d9d65b1d25e3284c33ce451e555c">More...</a><br /></td></tr>
<tr class="separator:gaa284d9d65b1d25e3284c33ce451e555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3991fac92ad55de3e3cf02bcc76f06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gacb3991fac92ad55de3e3cf02bcc76f06">FLSlice_Hash</a> (<a class="el" href="struct_f_l_slice.html">FLSlice</a> s) <a class="el" href="_base_8h.html#aaf76422cb887897c286992499106254d">FLPURE</a></td></tr>
<tr class="memdesc:gacb3991fac92ad55de3e3cf02bcc76f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 32-bit hash of a slice's data, suitable for use in hash tables.  <a href="#gacb3991fac92ad55de3e3cf02bcc76f06">More...</a><br /></td></tr>
<tr class="separator:gacb3991fac92ad55de3e3cf02bcc76f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdffe2bb52311b91bf998fa714b7a838"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gacdffe2bb52311b91bf998fa714b7a838">FLSlice_ToCString</a> (<a class="el" href="struct_f_l_slice.html">FLSlice</a> s, char *buffer, size_t capacity)</td></tr>
<tr class="memdesc:gacdffe2bb52311b91bf998fa714b7a838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a slice to a buffer, adding a trailing zero byte to make it a valid C string.  <a href="#gacdffe2bb52311b91bf998fa714b7a838">More...</a><br /></td></tr>
<tr class="separator:gacdffe2bb52311b91bf998fa714b7a838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66524dad4fc30818a3f18ac7a6b7ca28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga66524dad4fc30818a3f18ac7a6b7ca28">FLSliceResult_New</a> (size_t)</td></tr>
<tr class="memdesc:ga66524dad4fc30818a3f18ac7a6b7ca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a> of the given size, without initializing the buffer.  <a href="#ga66524dad4fc30818a3f18ac7a6b7ca28">More...</a><br /></td></tr>
<tr class="separator:ga66524dad4fc30818a3f18ac7a6b7ca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5e7e094a1a827337a4ac019b4ae663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gada5e7e094a1a827337a4ac019b4ae663">FLSlice_Copy</a> (<a class="el" href="struct_f_l_slice.html">FLSlice</a>)</td></tr>
<tr class="memdesc:gada5e7e094a1a827337a4ac019b4ae663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, copying the given slice.  <a href="#gada5e7e094a1a827337a4ac019b4ae663">More...</a><br /></td></tr>
<tr class="separator:gada5e7e094a1a827337a4ac019b4ae663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc20a9f39b6d5be79a5f917820cc8ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gafcc20a9f39b6d5be79a5f917820cc8ae">FLSliceResult_CreateWith</a> (const void *bytes, size_t size)</td></tr>
<tr class="memdesc:gafcc20a9f39b6d5be79a5f917820cc8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, copying <code>size</code> bytes starting at <code>buf</code>.  <a href="#gafcc20a9f39b6d5be79a5f917820cc8ae">More...</a><br /></td></tr>
<tr class="separator:gafcc20a9f39b6d5be79a5f917820cc8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699348717114834d5280c66d40d483de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga699348717114834d5280c66d40d483de">_FLBuf_Retain</a> (const void *)</td></tr>
<tr class="separator:ga699348717114834d5280c66d40d483de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975449fbf4e5662333feb4ed746f8487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga975449fbf4e5662333feb4ed746f8487">_FLBuf_Release</a> (const void *)</td></tr>
<tr class="separator:ga975449fbf4e5662333feb4ed746f8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce70f8e3d12d27fb0de3290a0307d18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga9ce70f8e3d12d27fb0de3290a0307d18">FLSliceResult_Retain</a> (<a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> s)</td></tr>
<tr class="memdesc:ga9ce70f8e3d12d27fb0de3290a0307d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the ref-count of a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>.  <a href="#ga9ce70f8e3d12d27fb0de3290a0307d18">More...</a><br /></td></tr>
<tr class="separator:ga9ce70f8e3d12d27fb0de3290a0307d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254cef250e1fb2b3cc8668c30373af04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#ga254cef250e1fb2b3cc8668c30373af04">FLSliceResult_Release</a> (<a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> s)</td></tr>
<tr class="memdesc:ga254cef250e1fb2b3cc8668c30373af04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the ref-count of a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, freeing its memory if it reached zero.  <a href="#ga254cef250e1fb2b3cc8668c30373af04">More...</a><br /></td></tr>
<tr class="separator:ga254cef250e1fb2b3cc8668c30373af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9442fc7a61c33e7932830a275238fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gabd9442fc7a61c33e7932830a275238fd">FLSliceResult_AsSlice</a> (<a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> sr)</td></tr>
<tr class="memdesc:gabd9442fc7a61c33e7932830a275238fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-casts a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a> to <a class="el" href="struct_f_l_slice.html" title="A simple reference to a block of memory.">FLSlice</a>, since C doesn't know it's a subclass.  <a href="#gabd9442fc7a61c33e7932830a275238fd">More...</a><br /></td></tr>
<tr class="separator:gabd9442fc7a61c33e7932830a275238fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc51222f8701a1b44688e9ac0a251b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_slice.html#gadc51222f8701a1b44688e9ac0a251b9b">FL_WipeMemory</a> (void *dst, size_t size)</td></tr>
<tr class="memdesc:gadc51222f8701a1b44688e9ac0a251b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes zeroes to <code>size</code> bytes of memory starting at <code>dst</code>.  <a href="#gadc51222f8701a1b44688e9ac0a251b9b">More...</a><br /></td></tr>
<tr class="separator:gadc51222f8701a1b44688e9ac0a251b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0e82def46e214a706216353705768453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e82def46e214a706216353705768453">&#9670;&nbsp;</a></span>FLSTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLSTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">STR</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="struct_f_l_slice.html">FLSlice</a>){(&quot;&quot; STR), sizeof((&quot;&quot; STR))-1})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro version of <a class="el" href="group___f_l_slice.html#gae9d0af13963246fd37fbf16c4b237f53">FLStr</a>, for use in initializing compile-time constants. </p>
<p><code>STR</code> must be a C string literal. Has zero runtime overhead. </p>

</div>
</div>
<a id="ga5445a97beaea63c3eadb1427c3a717d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5445a97beaea63c3eadb1427c3a717d8">&#9670;&nbsp;</a></span>kFLSliceNull</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define kFLSliceNull&#160;&#160;&#160;((<a class="el" href="struct_f_l_slice.html">FLSlice</a>){NULL, 0})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient constant denoting a null slice. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gabc10b138e3c1345a4396b39c11a1f0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc10b138e3c1345a4396b39c11a1f0d5">&#9670;&nbsp;</a></span>FLHeapSlice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_f_l_slice.html">FLSlice</a> <a class="el" href="group___f_l_slice.html#gabc10b138e3c1345a4396b39c11a1f0d5">FLHeapSlice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A heap-allocated, reference-counted slice. </p>
<p>This type is really just a hint in an API that the data can be retained instead of copied, by assigning it to an alloc_slice. You can just treat it like <a class="el" href="struct_f_l_slice.html" title="A simple reference to a block of memory.">FLSlice</a>. </p>

</div>
</div>
<a id="gabab0e7979cf6c99ffe836e84e55b6c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabab0e7979cf6c99ffe836e84e55b6c76">&#9670;&nbsp;</a></span>FLString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_f_l_slice.html">FLSlice</a> <a class="el" href="group___f_l_slice.html#gabab0e7979cf6c99ffe836e84e55b6c76">FLString</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab08438b1f08efeefe09ece8079734fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08438b1f08efeefe09ece8079734fdd">&#9670;&nbsp;</a></span>FLStringResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> <a class="el" href="group___f_l_slice.html#gab08438b1f08efeefe09ece8079734fdd">FLStringResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga975449fbf4e5662333feb4ed746f8487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975449fbf4e5662333feb4ed746f8487">&#9670;&nbsp;</a></span>_FLBuf_Release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _FLBuf_Release </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga699348717114834d5280c66d40d483de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699348717114834d5280c66d40d483de">&#9670;&nbsp;</a></span>_FLBuf_Retain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _FLBuf_Retain </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadc51222f8701a1b44688e9ac0a251b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc51222f8701a1b44688e9ac0a251b9b">&#9670;&nbsp;</a></span>FL_WipeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FL_WipeMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes zeroes to <code>size</code> bytes of memory starting at <code>dst</code>. </p>
<p>Unlike a call to <code>memset</code>, these writes cannot be optimized away by the compiler. This is useful for securely removing traces of passwords or encryption keys. </p>

</div>
</div>
<a id="gaa284d9d65b1d25e3284c33ce451e555c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa284d9d65b1d25e3284c33ce451e555c">&#9670;&nbsp;</a></span>FLSlice_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FLSlice_Compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographic comparison of two slices; basically like memcmp(), but taking into account differences in length. </p>

</div>
</div>
<a id="gada5e7e094a1a827337a4ac019b4ae663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5e7e094a1a827337a4ac019b4ae663">&#9670;&nbsp;</a></span>FLSlice_Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> FLSlice_Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, copying the given slice. </p>

</div>
</div>
<a id="ga23b5777450a091e1cecb4d1ff36c0a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b5777450a091e1cecb4d1ff36c0a23">&#9670;&nbsp;</a></span>FLSlice_Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FLSlice_Equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality test of two slices. </p>

</div>
</div>
<a id="gacb3991fac92ad55de3e3cf02bcc76f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3991fac92ad55de3e3cf02bcc76f06">&#9670;&nbsp;</a></span>FLSlice_Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FLSlice_Hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a 32-bit hash of a slice's data, suitable for use in hash tables. </p>

</div>
</div>
<a id="gacdffe2bb52311b91bf998fa714b7a838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdffe2bb52311b91bf998fa714b7a838">&#9670;&nbsp;</a></span>FLSlice_ToCString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FLSlice_ToCString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice.html">FLSlice</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a slice to a buffer, adding a trailing zero byte to make it a valid C string. </p>
<p>If there is not enough capacity the slice will be truncated, but the trailing zero byte is always written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="struct_f_l_slice.html" title="A simple reference to a block of memory.">FLSlice</a> to copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>Where to copy the bytes. At least <code>capacity</code> bytes must be available. </td></tr>
    <tr><td class="paramname">capacity</td><td>The maximum number of bytes to copy (including the trailing 0.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entire slice was copied, false if it was truncated. </dd></dl>

</div>
</div>
<a id="gabd9442fc7a61c33e7932830a275238fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9442fc7a61c33e7932830a275238fd">&#9670;&nbsp;</a></span>FLSliceResult_AsSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_f_l_slice.html">FLSlice</a> FLSliceResult_AsSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td>
          <td class="paramname"><em>sr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type-casts a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a> to <a class="el" href="struct_f_l_slice.html" title="A simple reference to a block of memory.">FLSlice</a>, since C doesn't know it's a subclass. </p>

</div>
</div>
<a id="gafcc20a9f39b6d5be79a5f917820cc8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcc20a9f39b6d5be79a5f917820cc8ae">&#9670;&nbsp;</a></span>FLSliceResult_CreateWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> FLSliceResult_CreateWith </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, copying <code>size</code> bytes starting at <code>buf</code>. </p>

</div>
</div>
<a id="ga66524dad4fc30818a3f18ac7a6b7ca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66524dad4fc30818a3f18ac7a6b7ca28">&#9670;&nbsp;</a></span>FLSliceResult_New()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> FLSliceResult_New </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a> of the given size, without initializing the buffer. </p>

</div>
</div>
<a id="ga254cef250e1fb2b3cc8668c30373af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254cef250e1fb2b3cc8668c30373af04">&#9670;&nbsp;</a></span>FLSliceResult_Release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void FLSliceResult_Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the ref-count of a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>, freeing its memory if it reached zero. </p>

</div>
</div>
<a id="ga9ce70f8e3d12d27fb0de3290a0307d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce70f8e3d12d27fb0de3290a0307d18">&#9670;&nbsp;</a></span>FLSliceResult_Retain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a> FLSliceResult_Retain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_l_slice_result.html">FLSliceResult</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the ref-count of a <a class="el" href="struct_f_l_slice_result.html" title="A heap-allocated block of memory returned from an API call.">FLSliceResult</a>. </p>

</div>
</div>
<a id="gae9d0af13963246fd37fbf16c4b237f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9d0af13963246fd37fbf16c4b237f53">&#9670;&nbsp;</a></span>FLStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_f_l_slice.html">FLSlice</a> FLStr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice pointing to the contents of a C string. </p>
<p>It's OK to pass NULL; this returns an empty slice. </p><dl class="section note"><dt>Note</dt><dd>If the string is a literal, it's more efficient to use <a class="el" href="group___f_l_slice.html#ga0e82def46e214a706216353705768453">FLSTR</a> instead. </dd>
<dd>
Performance is O(n) with the length of the string, since it has to call <code>strlen</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
