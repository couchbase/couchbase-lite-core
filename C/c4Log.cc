//
// c4Log.cc
//
// Copyright 2021-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#include "c4Log.h"
#include "c4Base.h"
#include "Backtrace.hh"
#include "Error.hh"
#include "Logging.hh"
#include "WebSocketInterface.hh"
#include "c4ExceptionUtils.hh"

using namespace std;
using namespace litecore;

// LCOV_EXCL_START
void c4log_writeToCallback(C4LogLevel level, C4LogCallback callback, bool preformatted) noexcept {
    LogDomain::setCallback((LogDomain::Callback_t)callback, preformatted);
    LogDomain::setCallbackLogLevel((LogLevel)level);
}

C4LogCallback c4log_getCallback() noexcept { return (C4LogCallback)LogDomain::currentCallback(); }

// LCOV_EXCL_STOP

bool c4log_writeToBinaryFile(C4LogFileOptions options, C4Error* outError) noexcept {
    return tryCatch(outError, [=] {
        LogFileOptions lfOptions{slice(options.base_path).asString(), (LogLevel)options.log_level,
                                 options.max_size_bytes, options.max_rotate_count, options.use_plaintext};

        string       buildInfo(c4_getBuildInfo());
        const string header = options.header.buf != nullptr ? slice(options.header).asString()
                                                            : string("Generated by LiteCore ") + buildInfo;
        LogDomain::writeEncodedLogsTo(lfOptions, header);
    });
}

C4LogLevel c4log_callbackLevel() noexcept { return (C4LogLevel)LogDomain::callbackLogLevel(); }  // LCOV_EXCL_LINE

C4LogLevel c4log_binaryFileLevel() noexcept { return (C4LogLevel)LogDomain::fileLogLevel(); }

void c4log_setCallbackLevel(C4LogLevel level) noexcept {
    LogDomain::setCallbackLogLevel((LogLevel)level);
}  //LCOV_EXCL_LINE

void c4log_setBinaryFileLevel(C4LogLevel level) noexcept { LogDomain::setFileLogLevel((LogLevel)level); }

C4StringResult c4log_binaryFilePath(void) C4API {
    auto options = LogDomain::currentLogFileOptions();
    if ( !options.path.empty() && !options.isPlaintext ) return C4StringResult(alloc_slice(options.path));
    else
        return {};
}

// NOLINTBEGIN(misc-misplaced-const,cppcoreguidelines-interfaces-global-init)
CBL_CORE_API C4LogDomain const kC4DefaultLog   = (C4LogDomain)&kC4Cpp_DefaultLog;
CBL_CORE_API C4LogDomain const kC4DatabaseLog  = (C4LogDomain)&DBLog;
CBL_CORE_API C4LogDomain const kC4QueryLog     = (C4LogDomain)&QueryLog;
CBL_CORE_API C4LogDomain const kC4SyncLog      = (C4LogDomain)&SyncLog;
CBL_CORE_API C4LogDomain const kC4WebSocketLog = (C4LogDomain)&websocket::WSLogDomain;

// NOLINTEND(misc-misplaced-const,cppcoreguidelines-interfaces-global-init)

C4LogDomain c4log_getDomain(const char* name, bool create) noexcept {
    if ( !name ) return kC4DefaultLog;
    auto domain = LogDomain::named(name);
    if ( !domain && create ) domain = new LogDomain(name, LogLevel::Info, true);
    return (C4LogDomain)domain;
}

const char* c4log_getDomainName(C4LogDomain c4Domain) noexcept {
    auto domain = (LogDomain*)c4Domain;
    return domain->name();
}

C4LogLevel c4log_getLevel(C4LogDomain c4Domain) noexcept {
    auto domain = (LogDomain*)c4Domain;
    return (C4LogLevel)domain->level();
}

void c4log_setLevel(C4LogDomain c4Domain, C4LogLevel level) noexcept {
    auto domain = (LogDomain*)c4Domain;
    domain->setLevel((LogLevel)level);
}

bool c4log_willLog(C4LogDomain c4Domain, C4LogLevel level) C4API {
    auto domain = (LogDomain*)c4Domain;
    return domain->willLog((LogLevel)level);
}

void c4log_warnOnErrors(bool warn) noexcept { error::sWarnOnError = warn; }

bool c4log_getWarnOnErrors() noexcept { return error::sWarnOnError; }

void c4log_enableFatalExceptionBacktrace() C4API {
    fleece::Backtrace::installTerminateHandler([](const string& backtrace) {
        c4log(kC4DefaultLog, kC4LogError,
              "FATAL ERROR (backtrace follows)\n"
              "********************\n"
              "%s\n"
              "******************** NOW TERMINATING",
              backtrace.c_str());
    });
}

void c4log_flushLogFiles() C4API { LogDomain::flushLogFiles(); }

void c4log(C4LogDomain c4Domain, C4LogLevel level, const char* fmt, ...) noexcept {
    va_list args;
    va_start(args, fmt);
    c4vlog(c4Domain, level, fmt, args);
    va_end(args);
}

void c4vlog(C4LogDomain c4Domain, C4LogLevel level, const char* fmt, va_list args) noexcept {
    try {
        ((LogDomain*)c4Domain)->vlog((LogLevel)level, fmt, args);
    } catch ( ... ) {}
}

// LCOV_EXCL_START
void c4slog(C4LogDomain c4Domain, C4LogLevel level, C4Slice msg) noexcept {
    if ( msg.buf == nullptr ) { return; }

    try {
        ((LogDomain*)c4Domain)->logNoCallback((LogLevel)level, "%.*s", FMTSLICE(msg));
    } catch ( ... ) {}
}

// LCOV_EXCL_STOP
