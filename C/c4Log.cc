//
// c4Log.cc
//
// Copyright 2021-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#include "c4Log.h"
#include "Backtrace.hh"
#include "Error.hh"
#include "Logging.hh"
#include "LogFiles.hh"
#include "PlatformIO.hh"  // For vasprintf on Windows
#include "WebSocketInterface.hh"
#include "c4ExceptionUtils.hh"

using namespace std;
using namespace litecore;

// NOLINTBEGIN(cppcoreguidelines-interfaces-global-init)
CBL_CORE_API const C4LogDomain kC4DefaultLog   = (C4LogDomain)&kC4Cpp_DefaultLog;
CBL_CORE_API const C4LogDomain kC4DatabaseLog  = (C4LogDomain)&DBLog;
CBL_CORE_API const C4LogDomain kC4QueryLog     = (C4LogDomain)&QueryLog;
CBL_CORE_API const C4LogDomain kC4SyncLog      = (C4LogDomain)&SyncLog;
CBL_CORE_API const C4LogDomain kC4WebSocketLog = (C4LogDomain)&websocket::WSLogDomain;

// NOLINTEND(cppcoreguidelines-interfaces-global-init)

#pragma mark - LOG OBSERVER:

// There is no real `C4LogObserver` struct. `C4LogObserver*` is an alias for C++ `LogObserver*`.

static inline LogObserver* toInternal(C4LogObserver* obs) { return reinterpret_cast<LogObserver*>(obs); }

static inline C4LogObserver* toExternal(Retained<LogObserver> obs) {
    return reinterpret_cast<C4LogObserver*>(std::move(obs).detach());
}

static vector<pair<LogDomain&, LogLevel>> convertDomains(C4LogObserverConfig const& config) {
    vector<pair<LogDomain&, LogLevel>> domains;
    domains.reserve(config.domainsCount);
    for ( size_t i = 0; i < config.domainsCount; ++i ) {
        auto [domain, level] = config.domains[i];
        if ( domain == nullptr || level < kC4LogDebug || level > kC4LogError )
            error::_throw(error::InvalidParameter, "invalid log domain or level");
        for ( size_t j = 0; j < i; j++ ) {
            if ( config.domains[j].domain == domain ) error::_throw(error::InvalidParameter, "duplicate log domain");
        }
        domains.emplace_back(*(LogDomain*)domain, LogLevel(level));
    }
    return domains;
}

static LogFiles::Options convertFileOptions(C4LogFileOptions const& fopts) {
    LogFiles::Options options{.directory   = slice(fopts.base_path).asString(),
                              .maxSize     = fopts.max_size_bytes,
                              .maxCount    = fopts.max_rotate_count,
                              .isPlaintext = fopts.use_plaintext};
    if ( fopts.header ) options.initialMessage = slice(fopts.header).asString();
    else
        options.initialMessage = "Generated by LiteCore "s + string(c4_getBuildInfo());
    return options;
}

C4LogObserver* c4log_newObserver(C4LogObserverConfig config, C4Error* outError) noexcept {
    try {
        if ( (config.callback != nullptr) + (config.fileOptions != nullptr) != 1 ) {
            c4error_return(LiteCoreDomain, kC4ErrorInvalidParameter,
                           "log observer needs either a callback or a file but not both"_sl, outError);
        }
        auto                  domains = convertDomains(config);
        Retained<LogObserver> obs;
        if ( config.callback ) {
            // Create LogCallback observer:
            auto thunk = [cb = config.callback, ctx = config.callbackContext](LogEntry const& e) {
                C4LogEntry c4entry{.timestamp = C4Timestamp(e.timestamp),
                                   .level     = C4LogLevel(e.level),
                                   .domain    = (C4LogDomain)&e.domain,
                                   .message   = slice(e.message)};
                cb(&c4entry, ctx);
            };
            obs = make_retained<LogFunction>(thunk);
        } else {
            // Create LogFiles observer:
            obs = make_retained<LogFiles>(convertFileOptions(*config.fileOptions));
        }
        LogObserver::add(obs, LogLevel(config.defaultLevel), domains);
        return toExternal(std::move(obs));
    }
    catchError(outError);
    return nullptr;
}

void c4log_removeObserver(C4LogObserver* observer) noexcept {
    LogObserver::remove(reinterpret_cast<LogObserver*>(observer));
}

C4LogObserver* c4log_replaceObserver(C4LogObserver* oldObs, C4LogObserverConfig config, C4Error* outError) noexcept {
    try {
        Retained<LogFiles> fileObs = dynamic_cast<LogFiles*>(toInternal(oldObs));
        if ( fileObs && config.fileOptions ) {
            // If the old and new config both log to files, try to update the LogFiles' options.
            // That allows it to keep log files open.
            auto domains = convertDomains(config);
            if ( fileObs->setOptions(convertFileOptions(*config.fileOptions)) ) {
                LogObserver::remove(fileObs);
                LogObserver::add(fileObs, LogLevel(config.defaultLevel), domains);
                return toExternal(std::move(fileObs));
            }
        }
        // By default just create a new observer and remove the old one:
        C4LogObserver* newObs = c4log_newObserver(config, outError);
        if ( newObs && oldObs ) c4log_removeObserver(oldObs);
        return newObs;
    }
    catchError(outError);
    return nullptr;
}

#pragma mark - CALLBACK LOGGING:

static Retained<LogCallback> sDefaultLogCallback;
static C4LogCallback         sDefaultLogCallbackFn;
static C4LogLevel            sDefaultLogCallbackLevel = kC4LogNone;

// LCOV_EXCL_START
void c4log_writeToCallback(C4LogLevel level, C4LogCallback callback, bool preformatted) noexcept {
    if ( !callback ) level = kC4LogNone;
    if ( sDefaultLogCallback ) {
        LogObserver::remove(sDefaultLogCallback);
        sDefaultLogCallback = nullptr;
    }
    if ( level != kC4LogNone ) {
        if ( preformatted ) {
            LogCallback::Callback_t thunk = [](void* ctx, LogEntry const& e) {
                va_list noArgs{};
                ((C4LogCallback)ctx)(C4LogDomain(&e.domain), C4LogLevel(e.level), e.message.data(), noArgs);
            };
            sDefaultLogCallback = make_retained<LogCallback>(thunk, (void*)callback);
        } else {
            LogCallback::RawCallback_t thunk = [](void* ctx, const LogDomain& domain, LogLevel level,
                                                  const char* format, va_list args) {
                ((C4LogCallback)ctx)(C4LogDomain(&domain), C4LogLevel(level), format, args);
            };
            sDefaultLogCallback = make_retained<LogCallback>(thunk, (void*)callback);
        }
        LogObserver::add(sDefaultLogCallback, LogLevel(level));
    }
    sDefaultLogCallbackLevel = level;
}

C4LogCallback c4log_getCallback() noexcept { return sDefaultLogCallbackFn; }

void c4log_defaultCallback(C4LogDomain domain, C4LogLevel level, const char* fmt, va_list args) {
    char* cstr = nullptr;
    if ( vasprintf(&cstr, fmt, args) < 0 ) return;
    LogCallback::consoleCallback(nullptr, LogEntry{.timestamp = uint64_t(c4_now()),
                                                   .domain    = *(LogDomain*)domain,
                                                   .level     = LogLevel(level),
                                                   .message   = cstr});
    free(cstr);
}

void c4log_setCallbackLevel(C4LogLevel level) noexcept {
    if ( level != sDefaultLogCallbackLevel && sDefaultLogCallback ) {
        LogObserver::remove(sDefaultLogCallback);
        LogObserver::add(sDefaultLogCallback, LogLevel(level));
    }
    sDefaultLogCallbackLevel = level;
}

C4LogLevel c4log_callbackLevel() noexcept { return sDefaultLogCallbackLevel; }  // LCOV_EXCL_LINE

// LCOV_EXCL_STOP

#pragma mark - FILE LOGGING:

static Retained<LogFiles> sDefaultLogFiles;
static C4LogLevel         sDefaultLogFilesLevel = kC4LogNone;

bool c4log_writeToBinaryFile(C4LogFileOptions options, C4Error* outError) noexcept {
    return tryCatch(outError, [=] {
        if ( options.base_path.empty() || options.log_level == kC4LogNone ) {
            // Disabling file logging:
            if ( sDefaultLogFiles ) {
                LogObserver::remove(sDefaultLogFiles);
                sDefaultLogFiles = nullptr;
            }
            sDefaultLogFilesLevel = kC4LogNone;
        } else {
            LogFiles::Options lfOptions = convertFileOptions(options);
            if ( !sDefaultLogFiles || !sDefaultLogFiles->setOptions(lfOptions) ) {
                auto newLogger = make_retained<LogFiles>(lfOptions);
                if ( sDefaultLogFiles ) LogObserver::remove(sDefaultLogFiles);
                sDefaultLogFiles = std::move(newLogger);
                LogObserver::add(sDefaultLogFiles, LogLevel(options.log_level));
            }
            sDefaultLogFilesLevel = options.log_level;
        }
    });
}

C4LogLevel c4log_binaryFileLevel() noexcept { return sDefaultLogFilesLevel; }

void c4log_setBinaryFileLevel(C4LogLevel level) noexcept {
    if ( sDefaultLogFiles && level != sDefaultLogFilesLevel ) {
        LogObserver::remove(sDefaultLogFiles);
        LogObserver::add(sDefaultLogFiles.get(), LogLevel(level));
        sDefaultLogFilesLevel = level;
    }
}

C4StringResult c4log_binaryFilePath() C4API {
    if ( sDefaultLogFiles ) {
        auto options = sDefaultLogFiles->options();
        if ( !options.isPlaintext ) return C4StringResult(alloc_slice(options.directory));
    }
    return {};
}

void c4log_flushLogFiles() C4API {
    if ( sDefaultLogFiles ) sDefaultLogFiles->flush();
}

#pragma mark - LOG DOMAINS AND LEVELS:

C4LogDomain c4log_getDomain(const char* name, bool create) noexcept {
    if ( !name ) return kC4DefaultLog;
    auto domain = LogDomain::named(name);
    if ( !domain && create ) domain = new LogDomain(name, LogLevel::Info, true);
    return (C4LogDomain)domain;
}

const char* c4log_getDomainName(C4LogDomain c4Domain) noexcept {
    auto domain = (LogDomain*)c4Domain;
    return domain->name();
}

C4LogLevel c4log_getLevel(C4LogDomain c4Domain) noexcept {
    auto domain = (LogDomain*)c4Domain;
    return (C4LogLevel)domain->level();
}

void c4log_setLevel(C4LogDomain c4Domain, C4LogLevel level) noexcept {
    auto domain = (LogDomain*)c4Domain;
    domain->setLevel((LogLevel)level);
}

bool c4log_willLog(C4LogDomain c4Domain, C4LogLevel level) C4API {
    auto domain = (LogDomain*)c4Domain;
    return domain->willLog((LogLevel)level);
}

void c4log_warnOnErrors(bool warn) noexcept { error::sWarnOnError = warn; }

bool c4log_getWarnOnErrors() noexcept { return error::sWarnOnError; }

void c4log_enableFatalExceptionBacktrace() C4API {
    fleece::Backtrace::installTerminateHandler([](const string& backtrace) {
        c4log(kC4DefaultLog, kC4LogError,
              "FATAL ERROR (backtrace follows)\n"
              "********************\n"
              "%s\n"
              "******************** NOW TERMINATING",
              backtrace.c_str());
    });
}

#pragma mark - WRITING LOG MESSAGES:

void c4log(C4LogDomain c4Domain, C4LogLevel level, const char* fmt, ...) noexcept {
    va_list args;
    va_start(args, fmt);
    c4vlog(c4Domain, level, fmt, args);
    va_end(args);
}

void c4vlog(C4LogDomain c4Domain, C4LogLevel level, const char* fmt, va_list args) noexcept {
    try {
        ((LogDomain*)c4Domain)->vlog((LogLevel)level, fmt, args);
    } catch ( ... ) {}
}

// LCOV_EXCL_START
void c4slog(C4LogDomain c4Domain, C4LogLevel level, C4Slice msg) noexcept {
    if ( msg.buf == nullptr ) { return; }

    try {
        ((LogDomain*)c4Domain)->logNoCallback((LogLevel)level, "%.*s", FMTSLICE(msg));
    } catch ( ... ) {}
}

// LCOV_EXCL_STOP
