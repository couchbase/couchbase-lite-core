//
// c4Base.cc
//
// Copyright 2016-Present Couchbase, Inc.
//
// Use of this software is governed by the Business Source License included
// in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
// in that file, in accordance with the Business Source License, use of this
// software will be governed by the Apache License, Version 2.0, included in
// the file licenses/APL2.txt.
//

#include "c4Base.h"
#include "c4Private.h"
#include "c4Internal.hh"
#include "c4ExceptionUtils.hh"

#include "Actor.hh"
#include "Backtrace.hh"
#include "KeyStore.hh"
#include "Logging.hh"
#include "StringUtil.hh"
#include "WebSocketInterface.hh"  // For websocket::WSLogDomain
#include "fleece/Fleece.hh"
#include "fleece/InstanceCounted.hh"
#include "Encoder.hh"
#include "sqlite3.h"
#include "repo_version.h"  // Generated by get_repo_version.sh at build time
#include "ParseDate.hh"
#include "UnicodeCollator.hh"
#include <cctype>
#include <csignal>
#include <algorithm>
#include <set>

#ifdef _MSC_VER
#    include <winerror.h>
#endif


using namespace std;
using namespace litecore;


extern "C" {
CBL_CORE_API_IMPL std::atomic_int gC4ExpectExceptions;
bool                              C4ExpectingExceptions();

bool C4ExpectingExceptions() { return gC4ExpectExceptions > 0; }  // LCOV_EXCL_LINE
}

// LCOV_EXCL_START
static string getBuildInfo() {
    static string commit;
#ifdef COUCHBASE_ENTERPRISE
    if ( commit.empty() ) { commit = stringprintf("%.16s+%.16s", GitCommitEE, GitCommit); }
    static const char* ee = "EE ";
#else
    if ( commit.empty() ) { commit = stringprintf("%.16s", GitCommit); }
    static const char* ee = "";
#endif
#if LiteCoreOfficial
    return stringprintf("%sbuild number %s, ID %.8s, from commit %s", ee, LiteCoreBuildNum, LiteCoreBuildID,
                        commit.c_str());
#else
    if ( strcmp(GitBranch, "HEAD") == (0) )
        return stringprintf("%sbuilt from commit %s%s on %s %s", ee, commit.c_str(), GitDirty, __DATE__, __TIME__);
    else
        return stringprintf("%sbuilt from %s branch, commit %s%s on %s %s", ee, GitBranch, commit.c_str(), GitDirty,
                            __DATE__, __TIME__);
#endif
}

C4StringResult c4_getBuildInfo() C4API { return toSliceResult(getBuildInfo()); }

C4StringResult c4_getVersion() C4API {
    string vers;
#if LiteCoreOfficial
    vers = stringprintf("%s (%s)", LiteCoreVersion, LiteCoreBuildNum);
#else
#    ifdef COUCHBASE_ENTERPRISE
    static const char* ee     = "-EE";
    string             commit = stringprintf("%.16s+%.16s", GitCommitEE, GitCommit);
#    else
    static const char* ee     = "";
    string             commit = stringprintf("%.16s", GitCommit);
#    endif
    if ( strcmp(GitBranch, "master") == (0) || strcmp(GitBranch, "HEAD") == (0) )
        vers = stringprintf("%s%s (%s%.1s)", LiteCoreVersion, ee, commit.c_str(), GitDirty);
    else
        vers = stringprintf("%s%s (%s:%s%.1s)", LiteCoreVersion, ee, GitBranch, commit.c_str(), GitDirty);
#endif
    return toSliceResult(vers);
}

C4SliceResult c4_getEnvironmentInfo() C4API {
    fleece::Encoder e;
    e.beginDict(2);
    e.writeKey(FLSTR(kC4EnvironmentTimezoneKey));
    time_t now;
    time(&now);
    chrono::seconds offset = fleece::GetLocalTZOffset(localtime(&now), false);
    e.writeInt(offset.count());
    e.writeKey(FLSTR(kC4EnvironmentSupportedLocales));

    auto locales = SupportedLocales();
    e.beginArray(locales.size());
    for ( const auto& locale : locales ) { e.writeString(locale); }
    e.endArray();
    e.endDict();

    return C4SliceResult(e.finish());
}

// LCOV_EXCL_STOP


C4Timestamp c4_now(void) C4API { return KeyStore::now(); }

#pragma mark - SLICES:

namespace litecore {

    C4SliceResult toSliceResult(const string& str) { return C4SliceResult(alloc_slice(str)); }

    void destructExtraInfo(C4ExtraInfo& x) noexcept {
        if ( x.destructor ) {
            x.destructor(x.pointer);
            x.destructor = nullptr;
        }
        x.pointer = nullptr;
    }

}  // namespace litecore

__cold void C4Error::warnCurrentException(const char* inFunction) noexcept {
    C4WarnError("Caught & ignored exception %s in %s", C4Error::fromCurrentException().description().c_str(),
                inFunction);
}

#pragma mark - REFERENCE COUNTED:

void* c4base_retain(void* obj) C4API { return retain((RefCounted*)obj); }

void c4base_release(void* obj) C4API { release((RefCounted*)obj); }

#pragma mark - INSTANCE COUNTED:

int c4_getObjectCount() noexcept { return fleece::InstanceCounted::liveInstanceCount(); }

// LCOV_EXCL_START
void c4_dumpInstances(void) C4API {
#if INSTANCECOUNTED_TRACK
    fleece::InstanceCounted::dumpInstances([](const fleece::InstanceCounted* obj) {
        if ( auto logger = dynamic_cast<const Logging*>(obj); logger )
            fprintf(stderr, "%s, ", logger->loggingName().c_str());
        fprintf(stderr, "a ");
    });
#endif
}

#pragma mark - MISCELLANEOUS:

bool c4_setTempDir(C4String path, C4Error* err) C4API {
    if ( sqlite3_temp_directory != nullptr ) {
        c4error_return(LiteCoreDomain, kC4ErrorUnsupported, C4STR("c4_setTempDir cannot be called more than once!"),
                       err);
        return false;
    }


    sqlite3_temp_directory = (char*)sqlite3_malloc((int)path.size + 1);
    memcpy(sqlite3_temp_directory, path.buf, path.size);
    sqlite3_temp_directory[path.size] = 0;
    return true;
}

// LCOV_EXCL_STOP


void c4_runAsyncTask(void (*task)(void*), void* context) C4API { actor::Mailbox::runAsyncTask(task, context); }
